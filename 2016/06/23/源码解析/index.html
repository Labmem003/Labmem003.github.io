<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<!--<![endif]-->

<head>
  <title>源码解析 | 振之的博客</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="振之的博客">
    <meta name="author" content="振之(炊事班程序猿小谢)">
    <meta name="description" content="我们应该多和厨子和程序猿交朋友" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="振之的博客" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
	
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    
    

    <!-- Custom stylesheet, (add custom styles here, always load last) -->
    <!-- Load our stylesheet for IE8 -->
    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- Google Webfonts (Monserrat 400/700, Open Sans 400/600) -->
    <link href='//fonts.useso.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>
    <link href='//fonts.useso.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'>

    <!-- Load our fonts individually if IE8+, to avoid faux bold & italic rendering -->
    <!--[if IE]>
    <link href='http://fonts.useso.com/css?family=Montserrat:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Montserrat:700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Open+Sans:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Open+Sans:600' rel='stylesheet' type='text/css'>
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->










  
  
  

  
  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            
            
        </ul>
        <!-- Lists in Slidebars -->
       <!-- <ul class="sb-menu secondary">
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li> -->
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.jpg" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">振之的博客</a></li>
                            <li class="nolink">我们应该多和厨子和程序猿交朋友</li>
                            
                            <li><a href="https://github.com/Labmem003" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->

        <!-- ============================ Hero Image =========================== -->

        <section id="hero" class="scrollme">
            <div class="container-fluid element-img" style="background: url() no-repeat center center fixed;background-size: cover">
                <div class="row">
                    <div class="col-xs-12 col-sm-8 col-sm-offset-2 col-md-8 col-md-offset-2 vertical-align cover boost text-center">
                        <div class="center-me animateme" data-when="exit" data-from="0" data-to="0.6" data-opacity="0" data-translatey="100">
                            <div>
                            	
                                <h2>About Cook and Code</h2>
                                <p></p>
				    			

                            </div>
                        </div>
                    </div>
                    <!-- // .col-md-12 -->
                </div>
                <div class="herofade beige-dk"></div>
            </div>
        </section>

        <!-- Height spacing helper -->
        <div class="heightblock"></div>
        <!-- // End height spacing helper -->

        <!-- ============================ END Hero Image =========================== -->
      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2016-06-23T15:08:10.000Z" itemprop="datePublished">
          2016-06-23
      </time>
    
</span>
                <h1>源码解析</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<blockquote>
<p> 项目地址：<a href="https://github.com/Countly/countly-sdk-android" target="_blank" rel="external">countly-sdk-android</a>，分析的版本：<a href="https://github.com/Countly/countly-sdk-android/commit/c105d06e573703d9e29d5c92068a41befa36f43f" target="_blank" rel="external">16.02.01 Release</a>，Demo 地址：<a href="https://github.com/Labmem003/zhenzhi-open-project-analysis/tree/master/countly-sdk-android-demo" target="_blank" rel="external">countly-sdk-android-demo</a><br> 分析者：<a href="https://github.com/Labmem003" target="_blank" rel="external">振之</a>，分析状态：完成</p>
</blockquote>
<p>工作需要用到了一个叫Countly的开源移动应用实时统计分析系统，类似于友盟。挺好奇这类统计系统的实现机制的，于是读了一下源码。项目其实十分简单，功能性代码比较多。原理上并没有什么特别高深莫测的地方，跟我们平常写业务代码的套路是一样一样的。</p>
<p>笔记如下，有需要／好奇的可以看看。</p>
<p>读完大概需要15分钟。</p>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="Countly"><a href="#Countly" class="headerlink" title="Countly"></a>Countly</h4><p>Countly 是一款类似于友盟的移动&amp;Web应用通用的实时统计分析系统，专注于易用性、扩展性和功能丰富程度。不同之处是 Countly 是开源的，任何人都可以将 Countly 客户端部署在自己的服务器并将开发工具包整合到他们的应用程序中。比友盟要简洁干净，关键是数据和程序都完全处于自己掌控之下，不愿被第三方掌握数据，或者有什么特殊需求的，可以自己满足自己了。</p>
<p>这里分析的是其 Android 端的 sdk, 以了解和学习移动应用统计类的工具收集 App 的使用情况和终端用户的行为的机制。主要功能包括 App 基本数据收集、自定义事件记录、崩溃报告。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>（1）将 Countly SDK 添加到您的项目<br>Android Studio<br>添加二进制 Maven 存储库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url  &quot;http://dl.bintray.com/countly/maven&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加 Countly SDK 依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;ly.count.android:sdk:15.06&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以直接下载 Jar 使用, 这里分析的是 <a href="https://github.com/Countly/countly-sdk-android/releases/download/16.02.01/sdk-16.02.01.jar" target="_blank" rel="external">sdk-16.02.01.jar</a>。</p>
<p>（2）服务器端程序的安装和使用<br>篇幅和重点所限，不详细介绍服务端安装使用，在<a href="https://cloud.count.ly" target="_blank" rel="external"> Countly 体验</a>创建一个应用试用即可。</p>
<p>（3）具体使用</p>
<p>设置 SDK，AppKey 在（2）的“管理－应用”中查看: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Countly.sharedInstance().init(this, &quot;https://YOUR_SERVER&quot;, &quot;YOUR_APP_KEY&quot;);</span><br></pre></td></tr></table></figure>
<p>记录事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Countly.sharedInstance().recordEvent(&quot;purchase&quot;, 1);</span><br></pre></td></tr></table></figure>
<p>设置崩溃报告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Countly.sharedInstance().enableCrashReporting()</span><br></pre></td></tr></table></figure>
<p>更详细的使用，可参照我写的小 <a href="https://github.com/Labmem003/zhenzhi-open-project-analysis/tree/master/countly-sdk-android-demo" target="_blank" rel="external">Demo</a>。</p>
<h3 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h3><p><a href="http://blog.qiji.tech/wp-content/uploads/2016/06/CountlyDesign.png" target="_blank" rel="external"><img src="http://blog.qiji.tech/wp-content/uploads/2016/06/CountlyDesign.png" alt="总体设计"></a></p>
<p>上面是 Countly SDK 的总体设计图。</p>
<p>SDK 主要处理 Event、Crash 和会话流（Session）3种数据记录请求。其中 Crash 和 Session 自动记录，并作为 Connection 持久存储到ConnectionQueue, 等待提交到服务器；Event 则由开发者调用，并配有一个 EventQueue 存储，但是在上报给服务器的时候依然是通过加入到 ConnectionQueue。也就是说，所有请求，最后都是 Connection。<br>ConnectionQueue 和 EventQueue 不是平常意义的 FIFO 队列，而是本地存储队列。包装了基于 SharePreference 实现的持久层 Store，每个请求会被字符串化，加上分隔符，添加到对应的SP键值后面。</p>
<p>最终存储在SP的 ConnectionQueue，大概长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;app_key=appKey_×tamp=3482759874&amp;hour=6&amp;dow=2&amp;session_duration=24&amp;location=3，8:::app_key=appKey_×tamp=345567773&amp;hour=8&amp;dow=3&amp;session_duration=12&amp;location=3，8&quot;</span><br></pre></td></tr></table></figure>
<p>OK, 接口地址知道，数据在手, 取出来按接口要求拼装好，fire the hole。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><a href="http://blog.qiji.tech/wp-content/uploads/2016/06/CountlyFlowchartDiagram.png" target="_blank" rel="external"><img src="http://blog.qiji.tech/wp-content/uploads/2016/06/CountlyFlowchartDiagram.png" alt="流程图"></a></p>
<h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><h4 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h4><p><a href="http://blog.qiji.tech/wp-content/uploads/2016/06/classship.png" target="_blank" rel="external"><img src="http://blog.qiji.tech/wp-content/uploads/2016/06/classship.png" alt="classship"></a>  </p>
<h4 id="类详细介绍"><a href="#类详细介绍" class="headerlink" title="类详细介绍"></a>类详细介绍</h4><p>结构很简单，一共就两个包，countly 核心包和 openudid 包。</p>
<p><a href="http://blog.qiji.tech/wp-content/uploads/2016/06/structure.png" target="_blank" rel="external"><img src="http://blog.qiji.tech/wp-content/uploads/2016/06/structure.png" alt="structure"></a></p>
<p>countly 包解决统计什么，怎么实施统计；而 openudid 包解决如何标记统计的数据来自何方。</p>
<h5 id="openudid-包"><a href="#openudid-包" class="headerlink" title="openudid 包"></a>openudid 包</h5><p>先来看看比较简单的 openudid 包，她是一个设备标识方案，能提供一个设备通用统一标识符（Unique Device IDentifier/UDID）。如果同一台设备上有多个 App 都用了这个包来生成 UDID，他们获取的 UDID 是一致的（即所谓设备标识）。当我们将统计数据发送给服务端时，会将 UDID 附上。不难想到，之后服务端算日活、描述用户特征、事件追踪等等各种后续的数据分析肯定都离不开 UDID ，算是很必要的基础设施。实际上她也是一个开源包<a href="https://github.com/vieux/OpenUDID" target="_blank" rel="external">OpenUDID</a>。</p>
<h6 id="OpenUDID-service-java"><a href="#OpenUDID-service-java" class="headerlink" title="OpenUDID_service.java"></a>OpenUDID_service.java</h6><p>这个类很简单，就是一个只重写了 onTransact 方法的 Service，支持跨进程调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class OpenUDID_service extends Service &#123;</span><br><span class="line">  @Override public IBinder onBind(Intent arg0) &#123;</span><br><span class="line">    return new Binder() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply,</span><br><span class="line">          int flags) &#123;</span><br><span class="line">        final SharedPreferences preferences =</span><br><span class="line">            getSharedPreferences(OpenUDID_manager.PREFS_NAME, Context.MODE_PRIVATE);</span><br><span class="line"></span><br><span class="line">        reply.writeInt(data.readInt()); //Return to the sender the input random number</span><br><span class="line">        reply.writeString(preferences.getString(OpenUDID_manager.PREF_KEY, null));</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它给调用者返回了两个值：</p>
<p>（1）把调用者传过来的 data 中的 int 参数又传回去了，起的是标识发起者的作用，类似于 startActivityForResult() 中的 requestCode。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reply.writeInt(data.readInt()); //Return to the sender the input random number</span><br></pre></td></tr></table></figure>
<p>（2）返回本进程获取到的 OpenUDID。还可以看到 OpenUDID 是用 SharePreferences 保存的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reply.writeString(preferences.getString(OpenUDID_manager.PREF_KEY, null));</span><br></pre></td></tr></table></figure>
<h6 id="OpenUDID-manager-java"><a href="#OpenUDID-manager-java" class="headerlink" title="OpenUDID_manager.java"></a>OpenUDID_manager.java</h6><p>调用 sync(Context context) 来初始化一个 udid, 策略是先看自己有木有，木有的话就从好基友那里拿，好基友也没有就只能自己撸一个出来。</p>
<p>一切都撸完之后，调用 getOpenUDID 就可以得到一枚 UDID 了。</p>
<p>（1）public static void sync(Context context)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//先尝试从本地 SharePreference 中获取</span><br><span class="line">OpenUDID=manager.mPreferences.getString(PREF_KEY,null);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (OpenUDID == null) //本地没有</span><br><span class="line">&#123;</span><br><span class="line">  //获取设备上所有的使用了该包的 OpenUDID_service 的 services 列表, intent 形式保存在 mMatchingIntents</span><br><span class="line">  manager.mMatchingIntents =</span><br><span class="line">      context.getPackageManager().queryIntentServices(new Intent(&quot;org.OpenUDID.GETUDID&quot;), 0);</span><br><span class="line"></span><br><span class="line">  if (manager.mMatchingIntents != null)</span><br><span class="line">  //尝试从别的使用了 OpenUDID_service 的进程获取</span><br><span class="line">  &#123;</span><br><span class="line">    manager.startService();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;//本地存在 UDID, 初始化完成，即可以直接调用 getOpenUDID() 来获取了</span><br><span class="line">  mInitialized = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)startService()<br>启动 mMatchingIntents 的首个 intent 并移除；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> private void startService() &#123;</span><br><span class="line">  if (mMatchingIntents.size() &gt; 0) &#123; //There are some Intents untested</span><br><span class="line">    if (LOG) &#123;</span><br><span class="line">      Log.d(TAG,</span><br><span class="line">          &quot;Trying service &quot; + mMatchingIntents.get(0).loadLabel(mContext.getPackageManager()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ServiceInfo servInfo = mMatchingIntents.get(0).serviceInfo;</span><br><span class="line">    final Intent i = new Intent();</span><br><span class="line">    i.setComponent(new ComponentName(servInfo.applicationInfo.packageName, servInfo.name));</span><br><span class="line">    mMatchingIntents.remove(0);</span><br><span class="line">    try &#123;  // try added by Lionscribe</span><br><span class="line">      mContext.bindService(i, this, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125; catch (SecurityException e) &#123;</span><br><span class="line">      startService();  // ignore this one, and start next one</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123; //No more service to test</span><br><span class="line"></span><br><span class="line">    getMostFrequentOpenUDID(); //Choose the most frequent</span><br><span class="line"></span><br><span class="line">    if (OpenUDID == null) //No OpenUDID was chosen, generate one			</span><br><span class="line">    &#123;</span><br><span class="line">      generateOpenUDID();</span><br><span class="line">    &#125;</span><br><span class="line">    if (LOG) Log.d(TAG, &quot;OpenUDID: &quot; + OpenUDID);</span><br><span class="line"></span><br><span class="line">    storeOpenUDID();//Store it locally</span><br><span class="line">    mInitialized = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若启动成功则可以拿到被启动进程的 UDID, 以 UDID 为键，次数为值存入 HashMap 中；然后再次 startService(); 结果是递归地启动了 mMatchingIntents 的所有 intent，得到一张记录着各个进程的不相同的 udid 及其次数的 Map。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void onServiceConnected(ComponentName className, IBinder service) &#123;</span><br><span class="line">  //Get the OpenUDID from the remote service</span><br><span class="line">  ...</span><br><span class="line">  final String _openUDID = reply.readString();</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  if (mReceivedOpenUDIDs.containsKey(_openUDID)) &#123;</span><br><span class="line">    mReceivedOpenUDIDs.put(_openUDID, mReceivedOpenUDIDs.get(_openUDID) + 1);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    mReceivedOpenUDIDs.put(_openUDID, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  startService(); //Try the next one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）private void getMostFrequentOpenUDID() ，返回 Map 中次数最多的 UDID</p>
<p>（4）private void generateOpenUDID() ，没有从其他进程领到 UDID，就生成一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  /*</span><br><span class="line">  * Generate a new OpenUDID</span><br><span class="line">  */</span><br><span class="line">  private void generateOpenUDID() &#123;</span><br><span class="line">    if (LOG) Log.d(TAG, &quot;Generating openUDID&quot;);</span><br><span class="line">    //Try to get the ANDROID_ID</span><br><span class="line">    OpenUDID = Secure.getString(mContext.getContentResolver(), Secure.ANDROID_ID);</span><br><span class="line">    if (OpenUDID == null || OpenUDID.equals(&quot;9774d56d682e549c&quot;) || OpenUDID.length() &lt; 15) &#123;</span><br><span class="line">      //if ANDROID_ID is null, or it&apos;s equals to the GalaxyTab generic ANDROID_ID or bad, generates a new one</span><br><span class="line">      final SecureRandom random = new SecureRandom();</span><br><span class="line">      OpenUDID = new BigInteger(64, random).toString(16);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">直接使用了 Android ID 来做 UDID，其实有点不靠谱。因为如果你恢复了出厂设置，那他就会改变的。而且如果你 root 了手机，你也可以改变这个 ID。不过如果不需要太精确的统计，也够用了。看你的需求吧。</span><br><span class="line"></span><br><span class="line">可以参考[这篇文章](http://www.bkjia.com/Androidjc/1036506.html)来修改适合你的 UDID。</span><br><span class="line"></span><br><span class="line">(5)public static String getOpenUDID(),就是getOpenUDID。</span><br><span class="line"></span><br><span class="line">##### countly 包</span><br><span class="line">概念解释</span><br><span class="line"></span><br><span class="line">Event，事件，以键值方式记录，键为事件名，值记录次数。</span><br><span class="line"></span><br><span class="line">Session，会话，定时更新；形成的会话流，代表应用的一次使用过程。</span><br><span class="line"></span><br><span class="line">Crash，崩溃。</span><br><span class="line"></span><br><span class="line">Connection，连接；以上请求（事件、会话、崩溃）都会转换为 Connection 提交给服务器。</span><br><span class="line">###### OpenUDIDAdapter.java</span><br><span class="line">包装了 UDID 包，提供 sync（），getOpenUDID（）。但是是用动态反射的方法封装的，不明白为什么。官方的 commit message 说了一句：call OpenUDID dynamically so that including the OpenUDID source is not necessary to get the Countly Android SDK to work when an app provides it&apos;s own deviceID。</span><br><span class="line">看懂的请告诉我。</span><br><span class="line">###### DeviceId.java</span><br><span class="line">代表设备 ID 的类。 </span><br><span class="line"></span><br><span class="line">（1）主要属性是</span><br><span class="line"></span><br><span class="line">private String id;//设备标识ID</span><br><span class="line"></span><br><span class="line">private Type type;//ID类型</span><br><span class="line"></span><br><span class="line">（2）ID类型分为3种</span><br></pre></td></tr></table></figure>
<p>  public static enum Type {<br>    DEVELOPER_SUPPLIED,//开发者自行定义和提供<br>    OPEN_UDID,//openUDID<br>    ADVERTISING_ID,//谷歌广告平台设备标识符<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openUDID 前面已介绍过，其他两种也是类似，不累述。</span><br><span class="line">###### DeviceInfo.java</span><br><span class="line">一个纯 POJO 类，用来存放设备信息，如设备名称、设备分辨率、版本号等。</span><br><span class="line"></span><br><span class="line">主要方法：</span><br><span class="line">static String getMetrics(final Context context)，返回 url-encoded 的属性 json 字符串。</span><br><span class="line">###### CrashDetails.java</span><br><span class="line">提供了一些静态方法来获取运行时环境信息，结合 DeviceInfo 类, 为 Crash 时提供详细的参考信息。</span><br><span class="line"></span><br><span class="line">主要方法：</span><br></pre></td></tr></table></figure></p>
<p>  static String getCrashData(final Context context, String error, Boolean nonfatal) {<br>    final JSONObject json = new JSONObject();</p>
<pre><code>fillJSONIfValuesNotEmpty(json, &quot;_error&quot;, error, &quot;_nonfatal&quot;, Boolean.toString(nonfatal),
    &quot;_logs&quot;, getLogs(), &quot;_device&quot;, DeviceInfo.getDevice(), &quot;_os&quot;, DeviceInfo.getOS(),
    &quot;_os_version&quot;, DeviceInfo.getOSVersion(), &quot;_resolution&quot;, DeviceInfo.getResolution(context),
    &quot;_app_version&quot;, DeviceInfo.getAppVersion(context), &quot;_manufacture&quot;, getManufacturer(),
    &quot;_cpu&quot;, getCpu(), &quot;_opengl&quot;, getOpenGL(context), &quot;_ram_current&quot;, getRamCurrent(context),
    &quot;_ram_total&quot;, getRamTotal(context), &quot;_disk_current&quot;, getDiskCurrent(), &quot;_disk_total&quot;,
    getDiskTotal(), &quot;_bat&quot;, getBatteryLevel(context), &quot;_run&quot;, getRunningTime(), &quot;_orientation&quot;,
    getOrientation(context), &quot;_root&quot;, isRooted(), &quot;_online&quot;, isOnline(context), &quot;_muted&quot;,
    isMuted(context), &quot;_background&quot;, isInBackground());

...
json.put(&quot;_custom&quot;, getCustomSegments());
...
String result = json.toString();

...
result = java.net.URLEncoder.encode(result, &quot;UTF-8&quot;);
...

return result;
</code></pre><p>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###### UserData.java</span><br><span class="line">类似 CrashDetail。</span><br></pre></td></tr></table></figure></p>
<p>  /<em>
   </em>Send provided values to server<br>   */<br>  public void save() {<br>    connectionQueue_.sendUserData();<br>    UserData.clear();<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### Event.java</span><br><span class="line">定义了一个事件的数据结构</span><br></pre></td></tr></table></figure></p>
<p>  public String key;//键，识别事件<br>  public int count;//发生此事件的次数<br>  public double sum;//事件的全部数值数据，比如一次支付事件的支付金额，可选<br>  public Map<string, string=""> segmentation;//分段键值对，用来扩展自定义数据，数量不受限制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由于多个事件可结合在单一请求中，为了正确报告和处理数据（特别是排队数据），还有下面3个属性用来提供数据记录时间：</span><br></pre></td></tr></table></figure></string,></p>
<p>  public int timestamp;//时间戳<br>  public int hour;//本地时间，0-23<br>  public int dow;//星期几</p>
<p>  JSONObject toJSON()<br>  static Event fromJSON(final JSONObject json)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">还有 fromJson 和 toJson 函数来在事件对象和 json 表示之间转换。</span><br><span class="line">###### 4.2.2.7 EventQueue.java</span><br><span class="line">这个类用来队列化 event，并且可以将 event 转化为 json，方便提交到服务器。</span><br><span class="line"></span><br><span class="line">（1）主要属性：</span><br></pre></td></tr></table></figure></p>
<p>  private final CountlyStore countlyStore_;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountlyStore 是一个持久化存储类，EventQueue 类其实就是对 CountlyStore 的一个封装，每次有 Event 添加进 queue，就会通过 CountlyStore 直接持久化存储到本地（本地队列的末尾）；出 queue 的时候也是直接从本地队列中移除。CountlyStore 在后面还会详细介绍。</span><br></pre></td></tr></table></figure></p>
<p>  /**</p>
<ul>
<li>Constructs an EventQueue.<br>*</li>
<li><p>@param countlyStore backing store to be used for local event queue persistence<br>*/<br>EventQueue(final CountlyStore countlyStore) {<br>countlyStore_ = countlyStore;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）主要方法：</span><br><span class="line">并不是真正意义上的 queue，使用 recordEvent 入队一个 Event 到本地，使用 events() 直接把整个队列提取出来并且转换为 urlEncoded的json串，可以直接用于提交给服务器。好处是合并请求，方便一次提交多个 event，当然也是因为配合 api。</span><br></pre></td></tr></table></figure>
<p>String events() {<br>String result;<br>//从CountlyStore取回EventQueue<br>final List<event> events = countlyStore_.eventsList();</event></p>
<p>//Json化<br>final JSONArray eventArray = new JSONArray();<br>for (Event e : events) {<br> eventArray.put(e.toJSON());<br>}</p>
<p>result = eventArray.toString();</p>
<p>countlyStore_.removeEvents(events);</p>
<p>//UrlEncode<br>try {<br> result = java.net.URLEncoder.encode(result, “UTF-8”);<br>} catch (UnsupportedEncodingException e) {<br> // should never happen because Android guarantees UTF-8 support<br>}</p>
<p>return result;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>void recordEvent(final String key, final Map<string, string=""> segmentation, final int count,<br> final double sum) {<br>…<br>//直接持久化存入本地 Event 队列<br>countlyStore_.addEvent(key, segmentation, timestamp, hour, dow, count, sum);<br>}</string,></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">###### CountlyStore.java</span><br><span class="line">该类使用 SharePreference 为 Event, Connection, Location 3类数据提供持久化服务.</span><br><span class="line">介绍存储方式。</span><br><span class="line"></span><br><span class="line">以 Event 为例，每次有新来的 Event，会先读取本地的 events, 把新来的 event 加到末尾，然后整个队列重新被 json 化存储到 Shareference。</span><br></pre></td></tr></table></figure>
<p>void addEvent(final Event event) {<br>final List<event> events = eventsList();<br>events.add(event);<br>preferences_.edit().putString(EVENTS_PREFERENCE, joinEvents(events, DELIMITER)).commit();<br>}</event></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">直接从 SharePreference 取出所有 json 表示的 events。</span><br></pre></td></tr></table></figure>
<p>public String[] events()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将 json 表示的 events 反序列化，并排序，返回。</span><br></pre></td></tr></table></figure>
<p>public List<event> eventsList() {<br>final String[] array = events();<br>final List<event> events = new ArrayList&lt;&gt;(array.length);<br>for (String s : array) {<br> try {<br>   final Event event = Event.fromJSON(new JSONObject(s));<br>   if (event != null) {</event></event></p>
<pre><code>events.add(event);
</code></pre><p>   }<br> } catch (JSONException ignored) {<br>   // should not happen since JSONObject is being constructed from previously stringified JSONObject<br>   // events -&gt; json objects -&gt; json strings -&gt; storage -&gt; json strings -&gt; here<br> }<br>}<br>// order the events from least to most recent<br>Collections.sort(events, new Comparator<event>() {<br> @Override public int compare(final Event e1, final Event e2) {<br>   return e1.timestamp - e2.timestamp;<br> }<br>});<br>return events;<br>}</event></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public String[] connections()<br>public String[] events()<br>public List<event> eventsList()</event></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### Countly.java</span><br><span class="line">暴露接口和驱动各个类工作的入口类。主要的属性是</span><br><span class="line">EventQueue，ConnectionQueue，和ScheduledExecutorService。</span><br><span class="line">（1）构造和 init</span><br><span class="line">调用其他接口前需先调用 init() 来初始化，主要是参数检验、初始化和配置 EventQueue，ConnectionQueue。构造的时候就开启了一个 1 分钟 1 次的定时任务。</span><br></pre></td></tr></table></figure>
<p>Countly() {<br>connectionQueue<em> = new ConnectionQueue();<br>Countly.userData = new UserData(connectionQueue</em>);<br>timerService<em> = Executors.newSingleThreadScheduledExecutor();<br>timerService</em>.scheduleWithFixedDelay(new Runnable() {<br> @Override public void run() {<br>   onTimer();<br> }<br>}, TIMER_DELAY_IN_SECONDS, TIMER_DELAY_IN_SECONDS, TimeUnit.SECONDS);<br>}</p>
<p>…<br> deviceIdInstance.init(context,countlyStore,true);</p>
<p>connectionQueue<em>.setServerURL(serverURL);<br>connectionQueue</em>.setAppKey(appKey);<br>connectionQueue<em>.setCountlyStore(countlyStore);<br>connectionQueue</em>.setDeviceId(deviceIdInstance);</p>
<p>eventQueue_=new</p>
<p>EventQueue(countlyStore);</p>
<p>…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）定时任务</span><br><span class="line">记录 session 和 event 到 connectionqueue，并触发发送数据行为，所有的数据都是从 connectionqueue 的 store 中取得。</span><br></pre></td></tr></table></figure>
<p>synchronized void onTimer() {<br>final boolean hasActiveSession = activityCount<em> &gt; 0;<br>if (hasActiveSession) {<br> if (!disableUpdateSessionRequests</em>) {<br>   connectionQueue<em>.updateSession(roundedSecondsSinceLastSessionDurationUpdate());<br> }<br> if (eventQueue</em>.size() &gt; 0) {<br>   connectionQueue<em>.recordEvents(eventQueue</em>.events());<br> }<br>}<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(3) Session 流开始和退出，利用 activityCount</span><br><span class="line">Android 没有很好的办法监听应用开始和结束，所以每个 Activity 都需要调用 Countly.shareInstance().onStart() 和 onStop 方法，方法内部用一个 int 变量 activityCount_ 来记录当前 Activity 数量。onStart时activityCount_＋1, onStop 时 －1。</span><br><span class="line"></span><br><span class="line">onStart 中，当 activityCount_＝＝1 时，应用启动， 开始 Session 流；</span><br><span class="line"></span><br><span class="line">onStop 中，当 activityCount_＝＝0 时，应用退出前台， 结束 Session 流。</span><br><span class="line"></span><br><span class="line">(4)异常捕获,使用 UncaughtExceptionHandler</span><br></pre></td></tr></table></figure>
<p>/**</p>
</li>
<li><p>Enable crash reporting to send unhandled crash reports to server<br>*/<br>public synchronized Countly enableCrashReporting() {<br>//get default handler<br>final Thread.UncaughtExceptionHandler oldHandler = Thread.getDefaultUncaughtExceptionHandler();</p>
<p>Thread.UncaughtExceptionHandler handler = new Thread.UncaughtExceptionHandler() {</p>
<p> @Override public void uncaughtException(Thread t, Throwable e) {<br>   StringWriter sw = new StringWriter();<br>   PrintWriter pw = new PrintWriter(sw);<br>   e.printStackTrace(pw);<br>   Countly.sharedInstance().connectionQueue_.sendCrashReport(sw.toString(), false);</p>
<p>   //if there was another handler before<br>   if (oldHandler != null) {</p>
<pre><code>//notify it also
oldHandler.uncaughtException(t, e);
</code></pre><p>   }<br> }<br>};</p>
<p>Thread.setDefaultUncaughtExceptionHandler(handler);<br>return this;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（5）记录事件</span><br><span class="line"></span><br><span class="line">事件先被记录在 eventQueue, 到了需要被发送的时候会被全部取出放入 connectionQueue。connectionQueue 有发送数据的能力，系统定时把 connectionQueue 中的多条数据合并发送到服务器。</span><br></pre></td></tr></table></figure>
<p>public synchronized void recordEvent(final String key, final Map<string, string=""> segmentation,<br> final int count, final double sum) {<br>…<br>eventQueue_.recordEvent(key, segmentation, count, sum);<br>sendEventsIfNeeded();<br>}</string,></p>
<p>void sendEventsIfNeeded() {<br>if (eventQueue_.size() &gt;= EVENT_QUEUE_SIZE<em>THRESHOLD) {<br> connectionQueue</em>.recordEvents(eventQueue_.events());<br>}<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### ConnectionQueue.java</span><br><span class="line">需要被发送的各种数据，包括前面说过的 event 和 crash 等，都在此提供发送接口，实际发送的时候都会被转换为 connection,持久化添加到connectionQueue 中，Tick 的时候由 ConnectionProcessor 从 Store 中取出发送到服务端。</span><br></pre></td></tr></table></figure>
<p>//该方法会被定时触发<br>void recordEvents(final String events) {<br>checkInternalState();<br>final String data = “app_key=”</p>
<ul>
<li>appKey_</li>
<li>“×tamp=”</li>
<li>Countly.currentTimestamp()</li>
<li>“&amp;hour=”</li>
<li>Countly.currentHour()</li>
<li>“&amp;dow=”</li>
<li>Countly.currentDayOfWeek()</li>
<li>“&amp;events=”</li>
<li>events;</li>
</ul>
<p>store_.addConnection(data);</p>
<p>tick();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tick，持久层有待发送连接且当前没有正在提交数据，则启动一个 ConnectionProcessor 来提交数据。</span><br></pre></td></tr></table></figure>
<p>void tick() {<br>if (!store<em>.isEmptyConnections() &amp;&amp; (connectionProcessorFuture</em> == null<br>   || connectionProcessorFuture<em>.isDone())) {<br> ensureExecutor();<br> connectionProcessorFuture</em> =</p>
<pre><code>executor_.submit(new ConnectionProcessor(serverURL_, store_, deviceId_, sslContext_));
</code></pre><p>}<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其他数据也跟 Events 类似，包括 session, location, userData, CrashReport</span><br></pre></td></tr></table></figure>
<p>void beginSession()<br>void updateSession(final int duration)<br>void endSession(final int duration)</p>
<p>void sendCrashReport(String error, boolean nonfatal)<br>void sendUserData()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###### ConnectionProcessor.java</span><br><span class="line">是个 Runnable，每次被 Run 的时候，从 Store 中取出当前所有的 Connections，用 http 发送。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>URLConnection urlConnectionForEventData(final String eventData)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拼装 url 并打开 Conn</span><br></pre></td></tr></table></figure></p>
<p>  public void run() {<br>    while (true) {<br>      …<br>      conn = urlConnectionForEventData(eventData);<br>      conn.connect();<br>    }<br>    // consume response stream<br>    responseStream = new BufferedInputStream(conn.getInputStream());<br>    final ByteArrayOutputStream responseData = new ByteArrayOutputStream(<br>        256); // big enough to handle success response without reallocating<br>    int c;<br>    while ((c = responseStream.read()) != -1) {<br>      responseData.write(c);<br>    }<br>    …<br>  }<br>```<br>从 Store 中取出数据，调用 urlConnectionForEventData（）生成 conn, 发起请求。</p>

            <div class="clearfix"></div>
            <hr class="nogutter">
            
    <! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
		   欣赏此文？求鼓励，求支持！
        </span>
        <br>
      </div>  
	<div id="donate_guide" class="donate_bar center hidden" >
		<!-- 支付宝打赏图案 -->
		<img src="/img/zhifubao.jpg" alt="支付宝打赏"> 
		<!-- 微信打赏图案 -->
		<img src="/img/weixin.png" alt="微信打赏">  
    </div>
	<script type="text/javascript">
		document.getElementById('btn_donate').onclick = function(){
			$('#donate_board').addClass('hidden');
			$('#donate_guide').removeClass('hidden');
		}
	</script>
</div>
<! -- 添加捐赠图标 -->

<span id="busuanzi_container_page_pv">
  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
        </div>
        
        <nav class="pagination" role="pagination">
    
    
    <a class="pull-right" href="/2016/06/05/test/">
        test →
    </a>
    
</nav>

        <div class="duoshuo">
<div class="ds-thread" data-thread-key="/2016/06/23/源码解析/" data-title="源码解析" data-url="http://www.greens1995.com/2016/06/23/源码解析/"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"greens1995"};
(function() {
	var ds = document.createElement('script');
	ds.type = 'text/javascript';ds.async = true;
	ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	ds.charset = 'UTF-8';
	(document.getElementsByTagName('head')[0] 
	 || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By 振之(炊事班程序猿小谢). All Rights Reserved.
                </p>
                <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/Labmem003" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
        <span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
        
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };
    
    resizeHero();
    
    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/jquery.flexslider-min.js"></script><!-- Flexslider plugin -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->

<!-- Initiate flexslider plugin -->
<script type="text/javascript">
    $(document).ready(function($) {
      $('.flexslider').flexslider({
        animation: "fade",
        prevText: "",
        nextText: "",
        directionNav: true
      });
    });
</script>

</body>
</html>
